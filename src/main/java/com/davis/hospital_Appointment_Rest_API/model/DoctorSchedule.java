package com.davis.hospital_Appointment_Rest_API.model;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;

import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import com.davis.hospital_Appointment_Rest_API.utils.LocalTimeDeserializer;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;

import jakarta.persistence.CollectionTable;
import jakarta.persistence.ElementCollection;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;

/**
 * Represents a doctor's daily schedule in the Hospital Appointment System.
 * <p>
 * This entity defines a doctor's working hours, break periods, and availability 
 * for appointments on specific days of the week. Each schedule entry contains:
 * </p>
 * <ul>
 *   <li>Working hours (start and end times)</li>
 *   <li>Break periods during the day</li>
 *   <li>Available appointment slots</li>
 *   <li>Confirmation status</li>
 * </ul>
 * 
 * <p><b>Relationships:</b>
 * <ul>
 *   <li>Many-to-one relationship with {@link Doctor}</li>
 *   <li>Element collection of {@link DoctorBreaks}</li>
 * </ul>
 * </p>
 * 
 * @author CYPRIAN DAVIS
 * @version 1.0
 * @since 2025-06-03
 * @see Doctor
 * @see DoctorBreaks
 */
@Entity
@Table(name = "Doctor_Schedule")
public class DoctorSchedule {
    
    /**
     * Unique identifier for the schedule entry.
     * <p>
     * Automatically generated by the database using identity strategy.
     * </p>
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    /**
     * The doctor associated with this schedule.
     * <p>
     * Represents a many-to-one relationship with the {@link Doctor} entity.
     * Foreign key column: doctorId
     * </p>
     */
    @ManyToOne
    @JoinColumn(name = "doctorId")
    private Doctor doctor;
    
    /**
     * The day of the week this schedule applies to.
     * <p>
     * Expected values: "Monday", "Tuesday", etc. (case-sensitive)
     * </p>
     */
    private String dayOfWeek;
    
    /**
     * The start time of the doctor's working hours.
     * <p>
     * Uses {@link LocalTime} to represent time without date.
     * Custom deserializer: {@link LocalTimeDeserializer}
     * </p>
     */
    @JsonDeserialize(using = LocalTimeDeserializer.class)
    private LocalTime startTime;
    
    /**
     * The end time of the doctor's working hours.
     * <p>
     * Must be after {@link #startTime}.
     * Uses {@link LocalTime} to represent time without date.
     * Custom deserializer: {@link LocalTimeDeserializer}
     * </p>
     */
    @JsonDeserialize(using = LocalTimeDeserializer.class)
    private LocalTime endTime;
    
    /**
     * Number of available appointment slots during this schedule period.
     * <p>
     * Calculated based on working hours minus break periods.
     * Must be a positive integer.
     * </p>
     */
    private int availableSlots;
    
    /**
     * Indicates if the doctor has confirmed this schedule.
     * <p>
     * When false, the schedule is tentative and may change.
     * When true, the schedule is confirmed and available for bookings.
     * </p>
     */
    private boolean isConfirmed;
    
    /**
     * Timestamp when this schedule was created.
     * <p>
     * Automatically set by Hibernate using {@link CreationTimestamp}.
     * </p>
     */
    @CreationTimestamp
    private LocalDateTime createdOn;
    
    /**
     * Timestamp when this schedule was last updated.
     * <p>
     * Automatically updated by Hibernate using {@link UpdateTimestamp}.
     * </p>
     */
    @UpdateTimestamp
    private LocalDateTime lastUpdated;
    
    /**
     * Collection of break periods during this schedule.
     * <p>
     * Stored in a separate table "Doctor_Breaks" with foreign key "scheduleId".
     * Each break contains type, start time, and end time.
     * </p>
     */
    @ElementCollection
    @CollectionTable(name = "Doctor_Breaks", joinColumns = @JoinColumn(name = "scheduleId"))
    private List<DoctorBreaks> breaks = new ArrayList<>();

    /**
     * Constructs a new DoctorSchedule with required parameters.
     *
     * @param doctor the associated doctor (must not be null)
     * @param dayOfWeek the day of week (e.g., "Monday", must not be blank)
     * @param startTime the working hours start time (must not be null)
     * @param endTime the working hours end time (must not be null and after startTime)
     * @param maximumAppointments the initial number of available slots (must be positive)
     */
    public DoctorSchedule(Doctor doctor, String dayOfWeek, LocalTime startTime, LocalTime endTime,
            int maximumAppointments) {
        this.doctor = doctor;
        this.dayOfWeek = dayOfWeek;
        this.startTime = startTime;
        this.endTime = endTime;
        this.availableSlots = maximumAppointments;
    }

    /**
     * Default constructor required by JPA.
     */
    public DoctorSchedule() {}

    // [All getter and setter methods remain unchanged]
    
    /**
     * Gets the list of break periods during this schedule.
     *
     * @return unmodifiable list of {@link DoctorBreaks} (never null)
     */
    public List<DoctorBreaks> getBreaks() {
        return List.copyOf(breaks);
    }

    /**
     * Replaces all break periods for this schedule.
     *
     * @param breaks new list of breaks (must not be null, can be empty)
     * @throws IllegalArgumentException if breaks parameter is null
     */
    public void setBreaks(List<DoctorBreaks> breaks) {
        if (breaks == null) {
            throw new IllegalArgumentException("Breaks list cannot be null");
        }
        this.breaks = new ArrayList<>(breaks);
    }
    
    /**
     * Adds a new break period to this schedule.
     *
     * @param breakToAdd the break to add (must not be null)
     * @return true if the break was added successfully
     * @throws IllegalArgumentException if breakToAdd is null
     */
    public boolean addBreak(DoctorBreaks breakToAdd) {
        if (breakToAdd == null) {
            throw new IllegalArgumentException("Break cannot be null");
        }
        return breaks.add(breakToAdd);
    }
}